<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web PCM Recorder v3 (GC修复版)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #status { font-weight: bold; margin-top: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        .log-box { background: #f0f0f0; border: 1px solid #ccc; padding: 10px; height: 150px; overflow-y: scroll; margin-top: 10px; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>

    <h2>麦克风 PCM 采集 v3 (强力修复版)</h2>
    <p>解决 "收到 0 个数据包" 的问题</p>
    
    <button id="btnStart" onclick="startRecording()">开始采集 (15s)</button>
    <button id="btnStop" onclick="stopRecording()" disabled>停止</button>

    <div id="status">准备就绪</div>
    <div id="log" class="log-box"></div>

    <script>
        // 【关键修复1】把变量定义在全局，防止被垃圾回收
        window.audioContext = null;
        window.scriptProcessor = null;
        window.mediaStreamSource = null;
        window.audioDataList = [];
        
        let isRecording = false;
        let autoStopTimer;

        function log(msg) {
            const box = document.getElementById('log');
            box.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
            box.scrollTop = box.scrollHeight;
            console.log(msg);
        }

        async function startRecording() {
            try {
                window.audioDataList = [];
                
                // 1. 获取麦克风流
                log('正在请求麦克风...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                log('麦克风获取成功');

                // 2. 创建 AudioContext
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 3. 创建源节点
                window.mediaStreamSource = window.audioContext.createMediaStreamSource(stream);

                // 4. 创建处理节点 (Buffer: 4096)
                // 【注意】必须挂在 window 下，防止 Chrome 垃圾回收机制把它清理掉
                window.scriptProcessor = window.audioContext.createScriptProcessor(4096, 1, 1);

                // 5. 【关键修复2】创建一个静音增益节点
                // 为了让 ScriptProcessor 工作，它必须连到扬声器，但我们不想听到回音
                const gainNode = window.audioContext.createGain();
                gainNode.gain.value = 0; // 设置音量为 0

                // 6. 连接图谱: Source -> Processor -> Gain(Mute) -> Destination
                window.mediaStreamSource.connect(window.scriptProcessor);
                window.scriptProcessor.connect(gainNode);
                gainNode.connect(window.audioContext.destination);

                log(`采样率: ${window.audioContext.sampleRate}Hz`);

                // 7. 处理回调
                window.scriptProcessor.onaudioprocess = function(e) {
                    if (!isRecording) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    // 必须深拷贝
                    const dataCopy = new Float32Array(inputData);
                    window.audioDataList.push(dataCopy);

                    // 打印前几个包证明活着
                    if (window.audioDataList.length % 50 === 1) {
                        log(`正在采集... 已存 ${window.audioDataList.length} 包`);
                    }
                };

                // 8. 确保 Context 处于运行状态 (Chrome 策略)
                if (window.audioContext.state === 'suspended') {
                    await window.audioContext.resume();
                    log('AudioContext 已强制唤醒');
                }

                isRecording = true;
                updateUI(true);

                // 15秒倒计时
                autoStopTimer = setTimeout(() => {
                    if(isRecording) stopRecording();
                }, 15000);

            } catch (err) {
                log('错误: ' + err.message);
                alert('启动失败，请查看日志');
            }
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            clearTimeout(autoStopTimer);

            // 断开连接
            if (window.scriptProcessor) window.scriptProcessor.disconnect();
            if (window.mediaStreamSource) window.mediaStreamSource.disconnect();
            if (window.audioContext) window.audioContext.close();

            updateUI(false);
            log(`采集结束。共收到 ${window.audioDataList.length} 个数据包`);

            if (window.audioDataList.length > 0) {
                downloadPCM();
            } else {
                log('【严重错误】依然没有采集到数据。请尝试重启浏览器。');
            }
        }

        function downloadPCM() {
            log('正在生成 PCM 文件...');
            let length = 0;
            window.audioDataList.forEach(item => length += item.length);
            
            const pcmData = new Int16Array(length);
            let offset = 0;

            for (let buf of window.audioDataList) {
                for (let i = 0; i < buf.length; i++) {
                    let s = Math.max(-1, Math.min(1, buf[i]));
                    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    pcmData[offset++] = s;
                }
            }

            const blob = new Blob([pcmData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // 文件名带上采样率
            a.download = `mic_record_${window.audioContext ? window.audioContext.sampleRate : 48000}hz.pcm`;
            a.click();
            log('下载已触发');
        }

        function updateUI(recording) {
            document.getElementById('btnStart').disabled = recording;
            document.getElementById('btnStop').disabled = !recording;
            document.getElementById('status').innerText = recording ? "状态: 录音中..." : "状态: 停止";
            document.getElementById('status').style.color = recording ? "red" : "black";
        }
    </script>
</body>
</html>